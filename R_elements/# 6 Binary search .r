# бинарный поиск
# Двоичный поиск заключается в том,
# что на каждом шаге множество объектов делится
# на две части и в работе остаётся та часть множества,
# где находится искомый объект. 

# 1 data
#a <- c(3, 1, 4, 1, 5)             # Пример массива
#r <- 
#a <- c(5, 7, -1, 9, 123, -436, -8) # array
#key <- 9  
a <- c(2,4,6,8,12)
key <- 6

# counting 1
{
  l <- 1                          # Левая граница
  r <- length(a) -1               # Правая граница
  while (l <= r ) {              # Пока границы не сошлись
    m <- floor((l + r) / 2)      # Находим середину области поиска
     if (a[m + 1] < key) 
    {                            # Учесть, что индексация в R с 1
      l <- m
    } 
    else 
    {
      if (a[m + 1] < key) { 
        l <- m}
      else {  
      r <- m                       # Сужение границ
      }
    }
    #cat('[',l, m, ']', a[m], '\n')
    
    l <- l + 1
  }
  cat("key=", key, "l=", l-1)                    # Вернуть индекс a[m] == key (учет индексации)
}


# counting 2 с функцией binSearch и вызовом этой функции
binSearch <- function(a, key) {
  l <- 1                          # Левая граница (индексация в R с 1)
  r <- length(a)                  # Правая граница
  
  while (l <= r) {                # Пока границы не пересеклись
    m <- floor((l + r) / 2)       # Находим середину
    
    if (a[m] == key) {            # Если ключ найден
      return(m)                   # Возвращаем индекс
    } else if (a[m] < key) {      # Если ключ больше элемента в середине
      l <- m + 1                  # Сдвигаем левую границу
    } else {
      r <- m - 1                  # Сдвигаем правую границу
    }
  }
  return(-1)                      # Если элемент не найден
}
# Пример использования
a <- c(1, 3, 5, 7, 9, 11)          # Отсортированный массив
key <- 7

result <- binSearch(a, key)        # вызов функции
if (result != -1) {
  cat("Элемент найден на позиции:", result, "\n")
} else {
  cat("Элемент не найден\n")
}
