# 0.0 base по 25му заданию

# 1 общая структура цикла перебора:
count = 0
for n in range(a, b+1):
  if (условие выполнено):
    count += 1
print(count)

# 2 проверить делимость числа n на число d -
# взятия остатка от деления n на x:
# если остаток равен 0, число n делится на x нацело

# проверка делимости:
if n % d == 0:
      print("Делится")
else: print("Не делится")

# 3 определить число делителей натурального числа n
# можно использовать цикл, в котором перебираются
# все возможные делители d от 1 до n,
# при обнаружении делителя увеличивается
# счётчик делителей:
count = 0
for d in range(1, n+1):
  if n % d == 0:
    count += 1
print(count)  # вывести количество делителей

# 4 удобно использовать динамический массив:
# сначала он пуст, а при обнаружении очередного
# делителя этот делитель  добавляется в массив:
divs = []
for d in range(1,n+1): # перебор всех возможных делителей
  if n % d == 0:       # если нашли делитель d
    divs.append(d)     # то добавили его в массив
print(sorted(divs))

# 5 простые числа
# простое число n делится только на 1 и само на себя,
# причём единица не считается простым числом;
# таким образом, любое простое число
# имеет только два делителя
# 2, 3, 5, 7,  

# для определения простоты числа можно считать
# общее количество его делителей;
# если их ровно два, то число простое,
# если не два – не простое:
nDel = 0          # количество делителей числа
for d in range(1, n+1): # все возможные делители - (3, n, 2) 0
  if n % d == 0:
    nDel += 1     # нашли ещё делитель
if nDel == 2:
  print( "Число простое" )
else: 
  print( "Число составное" )

p = True
for d in range(2, n): # все возможные делители
  if n % d == 0:
    p = False     # нашли ещё делитель
return p

p = True
for d in range(2, round(n**0.5)+2): # все возможные делители
  if n % d == 0:
    p = False     # нашли ещё делитель
return p
# 6 работу программы по поиску простых чисел
# можно ускорить: если уже найдено больше двух
# делителей, то число не простое и можно досрочно
# закончит работу цикла с помощью оператора break:
nDel = 0            # количество делителей числа
for d in range(1, n+1): # все возможные делители n+1 -> n
  if n % d == 0:
    nDel += 1       # нашли ещё делитель
    if nDel > 2:    # уже не простое число  
      break         # досрочный выход из цикла 
if nDel == 2:
  print( "Число простое" )
else: 
  print( "Число составное" )

# 7 считать количество делителей числа на отрезке (обратная задача к пп 6)
# [2; n–1]; как только хотя бы один такой делитель
# будет найден, можно завершить цикл, потому что
# число явно не простое:
nDel = 0         # количество делителей на [2; n-1]
for d in range(2, n):  #!!!! все простые числа - нечетные!!!
  if n % d == 0:
    nDel += 1    # нашли делитель
    break        # досрочный выход из цикла 
if nDel == 0:
  print( "Число простое" )
else: 
  print( "Число составное" )

# 8 можно сделать то же самое с помощью
# логической переменной:
prime = True       # сначала считаем число простым
for d in range(2, n):
  if n % d == 0:
    prime = False   # уже не простое
    break           # досрочный выход из цикла 
if prime:
  print( "Число простое" )
else: 
  print( "Число составное" )
# проверка делимости на все числа от 2 до n-1
# выполняется очень долго

# 9 оптимизация ускорения- наименьший из пары делителей,
# таких что a*b= , не превышает квадратного корня из n;
# поэтому можно закончить перебор значением n**0.5,
# округлив его до ближайшего целого числа;
# если на отрезке [2;n**0.5] не найден ни один делитель,
# их нет и на отрезке [n**0.5+1,n–1]
# следовательно, можно существенно ускорить перебор,
# изменив конечное значение переменной цикла:
#    for d in range(2, round(sqrt(n))+1):

x = x1 * x2

18: 1*18, 2*9, 3*6  -> перебор до 18**0.5

# 10
from math import sqrt

n = 1000
n1 = sqrt(n)
count = 0
for i in range(1, n+1): # O(n*n)
    for d in range(1, i+1): # O(n)
       if n % d == 0:
          count += 1
    print( count )  # количество делителей


#import math
# x = math.sqrt(9)
    
# 11 prime numbers - Простые числа на интервале [106000000; 107000000]?

num_from = 106000000
num_to = 107000000
for i in range(3, int((num_to/2)**0.5), 2):  # не весь интервал!
     if num_from <= 2*i*i <= num_to: # условие интервала!
          
          j_is_prime = True  # check i is prime
          for j in range(2, i//2):
              if i % j == 0:
                  j_is_prime = False

          if j_is_prime:
              print(2*i*i)

# 12 фиксация времени выполнения программы 
# time in programm
#import datetime, time
from datetime import datetime, time, date
t1 = datetime.now()
print(t1)
# program

t2 = datetime.now()
print(t2)
print(t1 - t2)
# -----
import time
t0 = time.strftime('%H:%M:%S')
print ('time:', t0)
# program
t1 = time.strftime('%H:%M:%S')
print ('time:', t1)
print ('time- delta:', t1, '-', t0)


# 13применение словаря
dict = {}
num = 0
nu = 1000
for n in range(10,15):
    v = []
    for k in range(1, n+1):
        if n%k==0:
            v.append(k)
    print(v)
    dict[n] = len(v)
 
print(dict)











